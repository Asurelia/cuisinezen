import * as functions from "firebase-functions";
import { db } from "../utils/firebase-admin";
import { COLLECTIONS, COST_OPTIMIZATION } from "../utils/constants";
import { Product, Recipe, Ingredient, ShoppingListItem } from "../types";

/**
 * Génération automatique de liste de courses basée sur les recettes planifiées
 * Analyse l'inventaire actuel et génère une liste optimisée
 */
export const generateShoppingList = functions
  .runWith({
    timeoutSeconds: COST_OPTIMIZATION.FUNCTION_TIMEOUT,
    memory: COST_OPTIMIZATION.MEMORY_SIZE,
    maxInstances: COST_OPTIMIZATION.MAX_INSTANCES,
  })
  .region("europe-west1")
  .https.onCall(async (data, context) => {
    if (!context.auth) {
      throw new functions.https.HttpsError(
        "unauthenticated",
        "L'utilisateur doit être authentifié"
      );
    }

    try {
      const { recipeIds, startDate, endDate } = data;
      
      if (!recipeIds || !Array.isArray(recipeIds)) {
        throw new functions.https.HttpsError(
          "invalid-argument",
          "recipeIds doit être un tableau"
        );
      }

      console.log(`Génération liste de courses pour ${recipeIds.length} recettes`);

      // 1. Récupérer les recettes sélectionnées
      const recipes = await getRecipesByIds(recipeIds);
      
      // 2. Calculer les ingrédients nécessaires totaux
      const requiredIngredients = calculateTotalIngredients(recipes);
      
      // 3. Récupérer l'inventaire actuel
      const currentInventory = await getCurrentInventory();
      
      // 4. Calculer ce qui manque
      const shoppingList = calculateShoppingNeeds(requiredIngredients, currentInventory);
      
      // 5. Optimiser la liste (regrouper, prioriser)
      const optimizedList = optimizeShoppingList(shoppingList);
      
      // 6. Sauvegarder la liste générée
      const listId = await saveShoppingList(optimizedList, {
        recipeIds,
        startDate,
        endDate,
        generatedAt: new Date(),
      });

      console.log(`Liste de courses générée avec ${optimizedList.length} articles`);

      return {
        success: true,
        listId,
        items: optimizedList,
        totalItems: optimizedList.length,
        estimatedCost: optimizedList.reduce((sum, item) => sum + (item.estimatedCost || 0), 0),
      };

    } catch (error) {
      console.error("Erreur génération liste de courses:", error);
      throw new functions.https.HttpsError(
        "internal",
        "Erreur lors de la génération de la liste"
      );
    }
  });

/**
 * Fonction automatique hebdomadaire de génération de liste
 * Basée sur les recettes populaires et l'historique
 */
export const weeklyShoppingListGeneration = functions
  .runWith({
    timeoutSeconds: COST_OPTIMIZATION.FUNCTION_TIMEOUT,
    memory: COST_OPTIMIZATION.MEMORY_SIZE,
    maxInstances: 1,
  })
  .region("europe-west1")
  .pubsub.schedule("0 18 * * 0") // Dimanche 18h
  .timeZone("Europe/Paris")
  .onRun(async (context) => {
    try {
      console.log("Génération automatique de la liste de courses hebdomadaire");

      // Récupérer les recettes les plus utilisées récemment
      const popularRecipes = await getPopularRecipes();
      
      if (popularRecipes.length === 0) {
        console.log("Aucune recette populaire trouvée");
        return;
      }

      // Générer la liste pour les recettes populaires
      const recipeIds = popularRecipes.map(r => r.id);
      const requiredIngredients = calculateTotalIngredients(popularRecipes);
      const currentInventory = await getCurrentInventory();
      const shoppingList = calculateShoppingNeeds(requiredIngredients, currentInventory);
      const optimizedList = optimizeShoppingList(shoppingList);

      // Sauvegarder avec marqueur "auto-generated"
      await saveShoppingList(optimizedList, {
        recipeIds,
        autoGenerated: true,
        generatedAt: new Date(),
        type: "weekly_suggestion",
      });

      console.log(`Liste automatique générée avec ${optimizedList.length} articles`);
      
      return { 
        success: true, 
        itemsCount: optimizedList.length,
        recipesAnalyzed: popularRecipes.length 
      };

    } catch (error) {
      console.error("Erreur génération automatique:", error);
      throw error;
    }
  });

/**
 * Récupérer les recettes par IDs
 */
async function getRecipesByIds(recipeIds: string[]): Promise<Recipe[]> {
  const recipes: Recipe[] = [];
  
  // Utiliser des batches pour optimiser les requêtes
  const batchSize = 10;
  for (let i = 0; i < recipeIds.length; i += batchSize) {
    const batch = recipeIds.slice(i, i + batchSize);
    const snapshot = await db.collection(COLLECTIONS.RECIPES)
      .where("__name__", "in", batch.map(id => db.collection(COLLECTIONS.RECIPES).doc(id)))
      .get();
    
    snapshot.docs.forEach(doc => {
      recipes.push({ id: doc.id, ...doc.data() } as Recipe);
    });
  }
  
  return recipes;
}

/**
 * Calculer les ingrédients totaux nécessaires
 */
function calculateTotalIngredients(recipes: Recipe[]): Map<string, { quantity: number; unit: string }> {
  const totalIngredients = new Map<string, { quantity: number; unit: string }>();
  
  recipes.forEach(recipe => {
    recipe.ingredients?.forEach(ingredient => {
      const existing = totalIngredients.get(ingredient.productId);
      
      if (existing) {
        // Additionner les quantités (en supposant même unité)
        if (existing.unit === ingredient.unit) {
          existing.quantity += ingredient.quantity;
        } else {
          // Gérer les conversions d'unités si nécessaire
          existing.quantity += convertUnits(ingredient.quantity, ingredient.unit, existing.unit);
        }
      } else {
        totalIngredients.set(ingredient.productId, {
          quantity: ingredient.quantity,
          unit: ingredient.unit,
        });
      }
    });
  });
  
  return totalIngredients;
}

/**
 * Récupérer l'inventaire actuel
 */
async function getCurrentInventory(): Promise<Map<string, number>> {
  const inventory = new Map<string, number>();
  
  const snapshot = await db.collection(COLLECTIONS.PRODUCTS).get();
  
  snapshot.docs.forEach(doc => {
    const product = doc.data() as Product;
    const totalQuantity = product.batches?.reduce((sum, batch) => sum + batch.quantity, 0) || 0;
    inventory.set(doc.id, totalQuantity);
  });
  
  return inventory;
}

/**
 * Calculer ce qui manque pour les courses
 */
function calculateShoppingNeeds(
  required: Map<string, { quantity: number; unit: string }>,
  inventory: Map<string, number>
): ShoppingListItem[] {
  const shoppingList: ShoppingListItem[] = [];
  
  required.forEach((needed, productId) => {
    const available = inventory.get(productId) || 0;
    const missing = needed.quantity - available;
    
    if (missing > 0) {
      // Récupérer le nom du produit (à optimiser avec un cache)
      shoppingList.push({
        productName: productId, // À remplacer par le vrai nom
        quantity: Math.ceil(missing), // Arrondir au supérieur
        unit: needed.unit,
        priority: determinePriority(missing, needed.quantity),
        estimatedCost: estimateProductCost(productId, missing),
      });
    }
  });
  
  return shoppingList;
}

/**
 * Optimiser la liste de courses
 */
function optimizeShoppingList(items: ShoppingListItem[]): ShoppingListItem[] {
  // Trier par priorité puis par coût
  return items
    .sort((a, b) => {
      const priorityOrder = { high: 3, medium: 2, low: 1 };
      const priorityDiff = priorityOrder[b.priority] - priorityOrder[a.priority];
      
      if (priorityDiff !== 0) return priorityDiff;
      
      // Si même priorité, trier par coût décroissant
      return (b.estimatedCost || 0) - (a.estimatedCost || 0);
    })
    .map(item => ({
      ...item,
      // Optimiser les quantités (lots, formats économiques)
      quantity: optimizeQuantity(item.quantity, item.unit),
    }));
}

/**
 * Récupérer les recettes populaires
 */
async function getPopularRecipes(): Promise<Recipe[]> {
  // Logique simplifiée - à améliorer avec un système de tracking d'usage
  const snapshot = await db.collection(COLLECTIONS.RECIPES)
    .limit(10)
    .get();
  
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Recipe));
}

/**
 * Sauvegarder la liste de courses
 */
async function saveShoppingList(items: ShoppingListItem[], metadata: any): Promise<string> {
  const doc = await db.collection(COLLECTIONS.SHOPPING_LISTS).add({
    items,
    metadata,
    status: "pending",
    createdAt: new Date(),
  });
  
  return doc.id;
}

// Fonctions utilitaires
function convertUnits(quantity: number, fromUnit: string, toUnit: string): number {
  // Conversions basiques - à étendre selon les besoins
  const conversions: Record<string, Record<string, number>> = {
    g: { kg: 0.001 },
    ml: { l: 0.001 },
  };
  
  const conversion = conversions[fromUnit]?.[toUnit];
  return conversion ? quantity * conversion : quantity;
}

function determinePriority(missing: number, total: number): "high" | "medium" | "low" {
  const percentage = missing / total;
  if (percentage > 0.8) return "high";
  if (percentage > 0.5) return "medium";
  return "low";
}

function estimateProductCost(productId: string, quantity: number): number {
  // À implémenter avec une base de données de prix
  // Pour l'instant, retourner une estimation basique
  return quantity * 2; // 2€ par unité en moyenne
}

function optimizeQuantity(quantity: number, unit: string): number {
  // Logique d'optimisation des quantités
  // Ex: arrondir aux lots standards
  if (unit === "piece") {
    return Math.ceil(quantity);
  }
  
  // Pour g/ml, arrondir aux 100g/ml près
  if (unit === "g" || unit === "ml") {
    return Math.ceil(quantity / 100) * 100;
  }
  
  return quantity;
}